package fastcampus.codingpackage.part3.ch04;

import java.util.Scanner;

/*
    풀이

    - 2×n 크기의 직사각형을 다음 타일들로 채우는 문제
        * 1×2 타일
        * 2×1 타일
        * 2×2 타일

    - 핵심 아이디어
        오른쪽 끝을 기준으로, "마지막에 어떤 형태의 타일 배치가 들어오는지"를 기준으로 경우를 나눈다.

    - 점화식 도출 과정

        1) 마지막에 세로 1×2 타일을 하나 놓는 경우
           - 오른쪽 끝 열 하나를 세로 타일로 채운다.
           - 나머지 영역은 2×(n-1) 크기.
           → 경우의 수: d[n-1]

        2) 마지막에 가로 2×1 타일을 하나 놓는 경우
           - 가로 2×1 타일은 위 또는 아래 중 하나에만 놓을 수 있다.
           - 이 상태에서는 남은 한 칸(아래 또는 위)을
             반드시 또 하나의 가로 2×1 타일로 채워야 한다.
           - 즉, 가로 2×1 타일은 항상 "두 개가 한 쌍"으로 들어가며,
             결과적으로 오른쪽 끝 두 열을 모두 사용하게 된다.
           - 나머지 영역은 2×(n-2) 크기.
           → 경우의 수: d[n-2]

        3) 마지막에 2×2 타일을 하나 놓는 경우
           - 오른쪽 끝 두 열을 2×2 타일 하나로 채운다.
           - 나머지 영역은 2×(n-2) 크기.
           → 경우의 수: d[n-2]

        ※ 2번과 3번은 배치 형태는 다르지만,
           둘 다 동일하게 2×(n-2) 영역에서 출발한다.
           따라서 d[n-2]가 두 번 더해진다.

    - 최종 점화식
        d[n] = d[n-1] + 2 * d[n-2]

    - 값이 커질 수 있으므로, 각 단계마다 10007로 나눈 나머지를 저장한다.
    - n ≤ 1000 이므로 O(n) 동적 계획법으로 충분히 해결 가능하다.
*/
class Ex11727 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] d = new int[1001];
        d[1] = 1;
        d[2] = 3;
        for (int i = 3; i <= n; i++) {
            d[i] = (d[i - 1] + d[i - 2] + d[i - 2]) % 10007;
        }
        System.out.println(d[n]);
    }

}
